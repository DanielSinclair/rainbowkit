---
title: 自定義主題
description: 創建自定義主題
---

# 自定義主題

## 創建自定義主題

> 注意：此 API 目前不穩定，可能會在不久的將來發生變化。 我們建議暫時使用 [內建主題](/docs/theming)。

雖然內建主題提供了一定程度的自定義，`Theme` 類型允許您使用較低層次的訪問權限來定義自己的自定義主題。

```tsx
import { RainbowKitProvider, Theme } from '@rainbow-me/rainbowkit';

const myCustomTheme: Theme = {
  blurs: {
    modalOverlay: '...',
  },
  colors: {
    accentColor: '...',
    accentColorForeground: '...',
    actionButtonBorder: '...',
    actionButtonBorderMobile: '...',
    actionButtonSecondaryBackground: '...',
    closeButton: '...',
    closeButtonBackground: '...',
    connectButtonBackground: '...',
    connectButtonBackgroundError: '...',
    connectButtonInnerBackground: '...',
    connectButtonText: '...',
    connectButtonTextError: '...',
    connectionIndicator: '...',
    downloadBottomCardBackground: '...',
    downloadTopCardBackground: '...',
    error: '...',
    generalBorder: '...',
    generalBorderDim: '...',
    menuItemBackground: '...',
    modalBackdrop: '...',
    modalBackground: '...',
    modalBorder: '...',
    modalText: '...',
    modalTextDim: '...',
    modalTextSecondary: '...',
    profileAction: '...',
    profileActionHover: '...',
    profileForeground: '...',
    selectedOptionBorder: '...',
    standby: '...',
  },
  fonts: {
    body: '...',
  },
  radii: {
    actionButton: '...',
    connectButton: '...',
    menuButton: '...',
    modal: '...',
    modalMobile: '...',
  },
  shadows: {
    connectButton: '...',
    dialog: '...',
    profileDetailsAction: '...',
    selectedOption: '...',
    selectedWallet: '...',
    walletLogo: '...',
  },
};

const App = () => (
  <RainbowKitProvider theme={myCustomTheme} {...etc}>
    {/* Your App */}
  </RainbowKitProvider>;
)
```

### 擴展內建主題

您可以在不重新定義整個主題的情況下擴展內建主題。 當您只想覆蓋特定的主題令牌時，這會很有用。

為此，安裝 `lodash.merge`（或同等工具）：

```bash
npm install lodash.merge
```

將其與您想要擴展的主題（例如：`darkTheme`）和 TypeScript `Theme` 類型一起導入：

```tsx
import merge from 'lodash.merge';
import {
  RainbowKitProvider,
  darkTheme,
  Theme,
} from '@rainbow-me/rainbowkit';
```

然後，將內建主題與您想覆蓋的主題令牌合併。 在這個例子中，我將 `accentColor` 令牌覆蓋為與我的品牌配色一致的強調色。

```tsx
const myTheme = merge(darkTheme(), {
  colors: {
    accentColor: '#07296d',
  },
} as Theme);
```

最後，您現在可以將自定義主題傳遞給 `RainbowKitProvider` 的 `theme` 屬性。

```tsx
const App = () => {
  return (
    <RainbowKitProvider theme={myTheme} {...etc}>
      {/* Your App */}
    </RainbowKitProvider>
  );
};
```

### 創建自定義主題選擇器

如果您的應用是伺服器/靜態渲染的並允許用戶手動切換主題，那麼 RainbowKit 的主題系統可以通過以下函數連接到自定義 CSS 選擇器，這些函數可以與任何 CSS-in-JS 系統一起使用：

- `cssStringFromTheme`
- `cssObjectFromTheme`

這些函數返回設置所有所需主題變量的 CSS。 由於支持字符串和對象，因此可以與任何 CSS-in-JS 系統集成。

作為基本示例，您可以為每個主題渲染自己的 `style` 元素並使用自定義選擇器。 由於我們控制了主題 CSS 的渲染，我們將 `null` 傳遞給 `theme` 屬性，以使 RainbowKitProvider 不會為我們渲染任何樣式。 另請注意在 cssStringFromTheme 函數中的 extends 選項的使用，該選項省略了與基礎主題相同的任何主題變量。

```tsx
import {
  RainbowKitProvider,
  cssStringFromTheme,
  lightTheme,
  darkTheme,
} from '@rainbow-me/rainbowkit';

const App = () => {
  return (
    <RainbowKitProvider theme={null} {...etc}>
      <style
        dangerouslySetInnerHTML={{
          __html: `
            :root {
              ${cssStringFromTheme(lightTheme)}
            }

            html[data-dark] {
              ${cssStringFromTheme(darkTheme, {
                extends: lightTheme,
              })}
            }
          `,
        }}
      />

      {/* ... */}
    </RainbowKitProvider>
  );
};
```
